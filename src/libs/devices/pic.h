#pragma once
#include <x86/io.h>
#include <bit.h>

/*  -------------------------------------------------------------------------
 * 8259A PROGRAMMABLE INTERRUPT CONTROLLER
 * The Intel 8259A Programmable Interrupt Controller handles up to eight
 * vectored priority interrupts for the CPU.
 * 
 * 
 * The Programmable Interrupt Controller (PIC) functions as an overall
 * manager in an interrupt-driven system environment. it accepts requests
 * from the peripheral equipment, determines which of the incoming
 * requests is of the highest importance (priority), ascertains whether
 * the incoming request has a high priority value than the level 
 * currently being serviced, and issues an interrupt to the CPU based on
 * this determination.
 *
 * Each peripheral device or structure usually has a special program or
 * 'routine' that is associated with its specific functional or
 * operational requirements; this is referred to as a "service routine".
 * the PIC, after issuing an 'interrupt' to the CPU, must somehow input
 * information into the CPU that can "point" the Program Counter to the
 * service routine associated with the requesting device. 
 *
 * The 8259A accepts two types of command words generated by the CPU:
 * 1. Initialization Command Words (ICWs): before normal operation can
 *    begin, each 8259A in the system must be brought to a starting point
 *    - by a sequence of 2 to 4 bytes timed by WR pulses.
 * 
 * 2. Operation Command Words (OCWs): These are the command words which
 *    command the 8259A to operate in various interrupt modes. these
 *    modes are:
 *    a. fully nested mode
 *    b. rotating priority mode
 *    c. special mask mode
 *    d. polled mode
 *
 * The OCWs can be written into 8259A anytime after initialzation.
 *
 * INITIALIZATION COMMAND WORDS (ICWs)
 * General:
 * 
 * ICW1
 *   master port:    0x20
 *   slave port:     0xA0
 *   7      6     5     4     3      2      1      0
 * ┌─────┬─────┬─────┬─────┬──────┬──────┬──────┬─────┐
 * │  0  │  0  │  0  │  1  │ LTIM │ ADI  │ SNAL │ IC4 │
 * └─────┴─────┴─────┴─────┴──────┴──────┴──────┴─────┘
 * IC4:  1 = ICW4 needed, 0 = no ICW4 needed
 * SNGL: 1 = single, 0 = cascade mode (has slave(s))
 * ADI:  call address interval 1 = interval of 4, 0 = interval of 8
 * LTIM: 1 = level triggered mode, 0 = edge triggered mode
 * Bit4: always 1
 *
 *
 *
 * ICW2
 *   master port:    0x21
 *   slave port:     0xa1
 *    7     6     5     4     3     2     1     0
 * ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
 * │ T7  │ T6  │ T5  │ T4  │ T3  │ ID2 │ ID1 │ ID0 │
 * └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
 * Bit 0-2: 
 * Bit 3-7: interrupt vector address
 *
 *
 *
 * Master ICW3
 *    7     6     5     4     3      2    1     0
 * ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
 * │ S7  │ S6  │ S5  │ S4  │ S3  │ S2  │ S1  │ S0  │
 * └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
 * Bit 0-7: 
 *   1 = IR input has a slave
 *   0 = IR input does NOT has a slave
 *
 *
 *
 * Slave ICW3
 *    7     6     5     4     3      2     1     0
 * ┌─────┬─────┬─────┬─────┬──────┬─────┬─────┬─────┐
 * │  0  │  0  │  0  │  0  │  0   │ ID2 │ ID1 │ ID0 │
 * └─────┴─────┴─────┴─────┴──────┴─────┴─────┴─────┘
 * ID0-ID2:  is the slave ID number. 
 *
 *
 *
 * ICW4
 *    7     6     5     4     3      2     1      0
 * ┌─────┬─────┬─────┬──────┬─────┬─────┬──────┬─────┐
 * │  0  │  0  │  0  │ SFNM │ BUF │ M/S │ AEOI │ μPM │
 * └─────┴─────┴─────┴──────┴─────┴─────┴──────┴─────┘
 * μPM:
 *   1 = 8086/8088 mode
 *   0 = MCS-80/85 mode
 * AEOI:
 *   1 = auto EOI
 *   0 = normal EOI
 * BUF + M/S
 * ┌─────┬─────┬──────────────────────┐
 * │ BUF │ M/S │                      │
 * ├─────┼─────┼──────────────────────┤
 * │ 0   │ X   │ Non-Buffered Mode    │
 * ├─────┼─────┼──────────────────────┤
 * │ 1   │ 0   │ Buffered Mode Slave  │
 * ├─────┼─────┼──────────────────────┤
 * │ 1   │ 1   │ Buffered Mode Master │
 * └─────┴─────┴──────────────────────┘
 * SFNM
 *   1 = Special Fully Nested Mode
 *   0 = Not Special Fully Nested Mode
 *
 *
 *
 * OPERATION COMMAND WORDS (COWs)
 *
 * OCW1
 *    7     6     5     4     3      2    1     0
 * ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
 * │ M7  │ M6  │ M5  │ M4  │ M3  │ M2  │ M1  │ M0  │
 * └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
 * M0-M7: Interrupt Mask
 *   1 = mask set
 *   0 = mask reset
 *
 *
 *
 * OCW2
 *    7     6     5     4     3     2     1     0
 * ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
 * │  R  │ SL  │ EOI │  0  │  0  │ L2  │ L1  │ L0  │
 * └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
 * L0-L2: IR Level to be acted upon.
 * R	  SL  EOI  Action
 * 0	  0	  1	   Non specific EOI (L3L2L1=000)
 * 0	  1	  1	   Specific EOI command (Interrupt to clear given by
 *                 L3L2L1)
 * 1	  0	  1	   Rotate priorities on non-specific EOI
 * 1	  0	  0	   Rotate priorities in auto EOI mode set
 * 0	  0	  0	   Rotate priorities in auto EOI mode clear
 * 1	  1	  1	   Rotate priority on specific EOI command (resets
 *                 current ISR bit)
 * 1	  1	  0	   Set priority (does not reset current ISR bit)
 * 0	  1	  0	   No operation
 *
 *
 *
 * OCW3
 *    7     6      5     4     3     2     1     0
 * ┌─────┬──────┬─────┬─────┬─────┬─────┬─────┬─────┐
 * │  0  │ ESMM │ SMM │  0  │  1  │  P  │ RR  │ RIS │
 * └─────┴──────┴─────┴─────┴─────┴─────┴─────┴─────┘
 * ESMM    SMM    Effect
 * 0       X      No effect
 * 1       0      Reset special mask
 * 1       1      Set special mask
 * ------------------------------------------------------------------------ */

class pic8259a
{
private:
    bool _initialized : 1 = false;
    enum
    {   // ports
        PIC_M_CTRL      = 0x20,
        PIC_M_DATA      = 0X21,
        PIC_S_CTRL      = 0xA0,
        PIC_S_DATA      = 0xA1
    };
public:
    pic8259a(pic8259a&&)            = delete;
    pic8259a(const pic8259a&)       = delete;
    void operator=(pic8259a&&)      = delete;
    void operator=(const pic8259a&) = delete;
public:
    enum DevIntrVct
    {
        DIV_BASE        = 0x20,
        DEV_TIMER       = 0x20, 
        DEV_KEYBOARD    = 0x21, 
        DEV_CASCADE     = 0x22, 
        DEV_SERI_PORT2  = 0x23, 
        DEV_SERI_PORT1  = 0x24, 
        DEV_PARL_PORT2  = 0x25, 
        DEV_FLOPPY      = 0x26, 
        DEV_PARL_PORT1  = 0x27, 
        DEV_RTC         = 0x28, 
        DEV_REDIRECT    = 0x29, 
        DEV_PS2         = 0x2C, 
        DEV_FPU_EXCEPT  = 0x2D, 
        DEV_HDD         = 0x2E,
    };
private:
    pic8259a() = default;

    void init();

    bool initialized() const {
        return _initialized;
    }
    
    void enable(DevIntrVct div) {
        __inner_set_div(div, false);
    }

    void disable(DevIntrVct div) {
        __inner_set_div(div, true); 
    }

    // imr: interrupt mask register
    uint8_t get_master_imr() {
        return x86_io::inb(PIC_M_DATA);
    }

    // imr: interrupt mask register
    uint8_t get_slave_imr() {
        return x86_io::inb(PIC_S_DATA);
    }
public:
    static pic8259a&
    instance() {
        static pic8259a s_pic;
        return s_pic;
    }

private:
    void
    __inner_set_div(DevIntrVct div, bool b) {
        uint8_t dev = div-DIV_BASE;
        uint8_t imr = dev < 8 ? get_master_imr() : get_slave_imr();
        lkl::bit_set(imr, 1 << dev, b);
        x86_io::outb(
            dev < 8 ? PIC_M_DATA: PIC_S_DATA,
            imr);
    }
};
