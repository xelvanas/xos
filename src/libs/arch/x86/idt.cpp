#include <x86/idt.h>
#include <print.h>

using namespace lkl;

uint32_t::pic8259a::_states = 0;
/*  -------------------------------------------------------------------------
 * 8259A PROGRAMMABLE INTERRUPT CONTROLLER
 * The Intel 8259A Programmable Interrupt Controller handles up to eight
 * vectored priority interrupts for the CPU.
 * 
 * 
 * The Programmable Interrupt Controller (PIC) functions as an overall
 * manager in an interrupt-driven system environment. it accepts requests
 * from the peripheral equipment, determines which of the incoming
 * requests is of the highest importance (priority), ascertains whether
 * the incoming request has a high priority value than the level 
 * currently being serviced, and issues an interrupt to the CPU based on
 * this determination.
 *
 * Each peripheral device or structure usually has a special program or
 * 'routine' that is associated with its specific functional or
 * operational requirements; this is referred to as a "service routine".
 * the PIC, after issuing an 'interrupt' to the CPU, must somehow input
 * information into the CPU that can "point" the Program Counter to the
 * service routine associated with the requesting device. 
 *
 * The 8259A accepts two types of command words generated by the CPU:
 * 1. Initialization Command Words (ICWs): before normal operation can
 *    begin, each 8259A in the system must be brought to a starting point
 *    - by a sequence of 2 to 4 bytes timed by WR pulses.
 * 
 * 2. Operation Command Words (OCWs): These are the command words which
 *    command the 8259A to operate in various interrupt modes. these
 *    modes are:
 *    a. fully nested mode
 *    b. rotating priority mode
 *    c. special mask mode
 *    d. polled mode
 *
 * The OCWs can be written into 8259A anytime after initialzation.
 *
 * INITIALIZATION COMMAND WORDS (ICWs)
 * General:
 * 
 * ICW1
 *   master port:    0x20
 *   slave port:     0xA0
 *   7      6     5     4     3      2      1      0
 * ┌─────┬─────┬─────┬─────┬──────┬──────┬──────┬─────┐
 * │  0  │  0  │  0  │  1  │ LTIM │ ADI  │ SNAL │ IC4 │
 * └─────┴─────┴─────┴─────┴──────┴──────┴──────┴─────┘
 * IC4:  1 = ICW4 needed, 0 = no ICW4 needed
 * SNGL: 1 = single, 0 = cascade mode (has slave(s))
 * ADI:  call address interval 1 = interval of 4, 0 = interval of 8
 * LTIM: 1 = level triggered mode, 0 = edge triggered mode
 * Bit4: always 1
 *
 *
 *
 * ICW2
 *   master port:    0x21
 *   slave port:     0xa1
 *    7     6     5     4     3     2     1     0
 * ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
 * │ T7  │ T6  │ T5  │ T4  │ T3  │ ID2 │ ID1 │ ID0 │
 * └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
 * Bit 0-2: 
 * Bit 3-7: interrupt vector address
 *
 *
 *
 * Master ICW3
 *    7     6     5     4     3      2    1     0
 * ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
 * │ S7  │ S6  │ S5  │ S4  │ S3  │ S2  │ S1  │ S0  │
 * └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
 * Bit 0-7: 
 *   1 = IR input has a slave
 *   0 = IR input does NOT has a slave
 *
 *
 *
 * Slave ICW3
 *    7     6     5     4     3      2     1     0
 * ┌─────┬─────┬─────┬─────┬──────┬─────┬─────┬─────┐
 * │  0  │  0  │  0  │  0  │  0   │ ID2 │ ID1 │ ID0 │
 * └─────┴─────┴─────┴─────┴──────┴─────┴─────┴─────┘
 * ID0-ID2:  is the slave ID number. 
 *
 *
 *
 * ICW4
 *    7     6     5     4     3      2     1      0
 * ┌─────┬─────┬─────┬──────┬─────┬─────┬──────┬─────┐
 * │  0  │  0  │  0  │ SFNM │ BUF │ M/S │ AEOI │ μPM │
 * └─────┴─────┴─────┴──────┴─────┴─────┴──────┴─────┘
 * μPM:
 *   1 = 8086/8088 mode
 *   0 = MCS-80/85 mode
 * AEOI:
 *   1 = auto EOI
 *   0 = normal EOI
 * BUF + M/S
 * ┌─────┬─────┬──────────────────────┐
 * │ BUF │ M/S │                      │
 * ├─────┼─────┼──────────────────────┤
 * │ 0   │ X   │ Non-Buffered Mode    │
 * ├─────┼─────┼──────────────────────┤
 * │ 1   │ 0   │ Buffered Mode Slave  │
 * ├─────┼─────┼──────────────────────┤
 * │ 1   │ 1   │ Buffered Mode Master │
 * └─────┴─────┴──────────────────────┘
 * SFNM
 *   1 = Special Fully Nested Mode
 *   0 = Not Special Fully Nested Mode
 *
 *
 *
 * OPERATION COMMAND WORDS (COWs)
 *
 * OCW1
 *    7     6     5     4     3      2    1     0
 * ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
 * │ M7  │ M6  │ M5  │ M4  │ M3  │ M2  │ M1  │ M0  │
 * └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
 * M0-M7: Interrupt Mask
 *   1 = mask set
 *   0 = mask reset
 *
 *
 *
 * OCW2
 *    7     6     5     4     3     2     1     0
 * ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
 * │  R  │ SL  │ EOI │  0  │  0  │ L2  │ L1  │ L0  │
 * └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
 * L0-L2: IR Level to be acted upon.
 * R	  SL  EOI  Action
 * 0	  0	  1	   Non specific EOI (L3L2L1=000)
 * 0	  1	  1	   Specific EOI command (Interrupt to clear given by
 *                 L3L2L1)
 * 1	  0	  1	   Rotate priorities on non-specific EOI
 * 1	  0	  0	   Rotate priorities in auto EOI mode set
 * 0	  0	  0	   Rotate priorities in auto EOI mode clear
 * 1	  1	  1	   Rotate priority on specific EOI command (resets
 *                 current ISR bit)
 * 1	  1	  0	   Set priority (does not reset current ISR bit)
 * 0	  1	  0	   No operation
 *
 *
 *
 * OCW3
 *    7     6      5     4     3     2     1     0
 * ┌─────┬──────┬─────┬─────┬─────┬─────┬─────┬─────┐
 * │  0  │ ESMM │ SMM │  0  │  1  │  P  │ RR  │ RIS │
 * └─────┴──────┴─────┴─────┴─────┴─────┴─────┴─────┘
 * ESMM    SMM    Effect
 * 0       X      No effect
 * 1       0      Reset special mask
 * 1       1      Set special mask
 * ------------------------------------------------------------------------ */

void pic8259a::init()
{
    // OS only needs initialization once
    if(bit_test(_states, PIC_INITIALIZED)) {
        return;
    }
    //-------------------------------------------------------------------
    // INITIALIZE MASTER 8259A
    // ICW 1: port 0x20
    // Bit 0: IC4
    //        1 = ICW4 needed, 0 = no ICW4 needed, x86: 1
    // Bit 1: Single
    //        1 = single, 0 = cascade mode (has slave(s))
    // Bit 2: for 8025, x86: 0
    // Bit 3: 1 = level triggered mode, 0 = edge triggered mode
    // Bit 4: always 1 on x86
    // Bit 5-7: for 8085, x86: 0
    x86_io::outb(PIC_M_CTRL, 0b00010001); // bit 4 and bit 0
    
    // ICW 2: port 0x21/0xA1
    // 3-7 bits indicate starting interrupt vector (SIV)
    // 0-2 bits indicate current interrupt vector (CIV)
    // the real interrupt vector = SIV + CIV
    // 8259A only needs to know SIV
    // NOTICE: we specify 0x20 (decimal:32, binary: 0b00100000)
    // it doesn't mean that most-significant 5 bits 0xb00100 indicates
    // that our starting 'interrupt-vector' is 0b00100 = 4.
    // it says, our starting 'interrupt-vector' is 32.
    // you cannot specify a number like 0b0000'1111 = 15, 3 least
    // significant bits are ignored and will be filled by 8259A.
    x86_io::outb(PIC_M_DATA, 0b0010'0000); // 32
    
    // ICW 3 (Master): port 0x21/0xA1
    // any bit set 1 indicates that IR input has a slave
    x86_io::outb(PIC_M_DATA, 0b0000'0100);
    
    // ICW 4:
    // only bit we need to set for now is: μPM = 1 = 8086/8088 mode
    x86_io::outb(PIC_M_DATA, 0b0000'0001);

    //-------------------------------------------------------------------
    // INITIALIZE SLAVE 8259A
    // ICW 1: same as master
    x86_io::outb(PIC_S_CTRL, 0x11);

    // ICW 2: 0x28 = 0b0010'1000 = 40
    // starting 'interrupt-vector' is 40
    x86_io::outb(PIC_S_DATA, 0x28);

    // ICW 3: which master IR input the slave 8259A is connecting.
    x86_io::outb(PIC_S_DATA, 0x02);

    // ICW 4: same as master
    x86_io::outb(PIC_S_DATA, 0x01);

    // OCW 1: 1 indicates the channel is masked
    //        0 indicates the channel is enabled.
    // all irq masked at beginning.
    x86_io::outb(PIC_M_DATA, 0b1111'1111);

    // Slave OCW 1: all channel masked
    x86_io::outb(PIC_S_DATA, 0b1111'1111);

    bit_set(_states, PIC_INITIALIZED, true);
}

print_t<def_screen_t, x86_io> pt(color_t::B_GREEN | color_t::F_WHITE);
void main_intr_handler(uint16_t num) {
    static int number = 0;
    pt.add_char('A'+ (number%26));
    pt.add_char(' ');
    number++;
    // dbg_msg("x")
}
